# Elysium v0.3.0 - Onboarding System Spec

## Overview

First-time user experience (FTUE) 시스템. 새 사용자가 MCP를 처음 연결했을 때 **AI와 대화하며** 볼트 구조와 스키마를 함께 설정.

## Design Philosophy

**"Guided, not Automated"**

- 단순 자동화 ❌ → 유저와 함께 세팅하는 위자드 ✅
- 기본값 추천하되 커스텀 허용
- 각 설정의 **의미와 목적**을 설명
- AI가 스키마 문서를 참조하여 맥락있는 가이드 제공

## Problem Statement

현재 문제점:
1. 첫 사용자가 어디서부터 시작해야 할지 모름
2. 스키마 필드(type, status, area)의 의미를 모름
3. 기본값이 자신의 볼트에 맞는지 판단 어려움
4. Footer marker 개념과 목적 이해 부족
5. 임베딩 인덱스 빌드 타이밍 모름

## Solution

### 1. 자동 감지 시스템

볼트 상태를 분석하여 초기 설정 필요 여부 판단:

```rust
pub struct VaultReadiness {
    pub has_config: bool,           // .elysium.json 존재
    pub has_embeddings: bool,       // search.db 존재 + 인덱스된 노트 수 > 0
    pub has_folder_structure: bool, // 필수 폴더 존재
    pub footer_coverage: f32,       // footer marker 비율 (0.0 ~ 1.0)
    pub schema_compliance: f32,     // 스키마 준수율 (0.0 ~ 1.0)
}

impl VaultReadiness {
    pub fn needs_onboarding(&self) -> bool {
        !self.has_config
        || !self.has_embeddings
        || !self.has_folder_structure
        || self.footer_coverage < 0.5
    }

    pub fn is_fully_ready(&self) -> bool {
        self.has_config
        && self.has_embeddings
        && self.has_folder_structure
        && self.footer_coverage > 0.9
        && self.schema_compliance > 0.8
    }
}
```

### 2. Interactive Wizard Flow (핵심)

**5단계 가이드형 설정**:

```
┌─────────────────────────────────────────────────────────────┐
│  Step 1: 볼트 현황 분석                                      │
│  - 기존 노트 수, 폴더 구조 파악                               │
│  - 이미 사용 중인 frontmatter 패턴 감지                       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Step 2: 폴더 구조 설정                                      │
│  - 기본값 제안: Notes/, Projects/, Archive/                  │
│  - 유저 커스텀 허용 (예: "나는 Zettelkasten 스타일이야")       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Step 3: 스키마 설정 (type, status, area)                    │
│  - 각 필드의 목적 설명                                        │
│  - 기본값 제안 + 유저 상황에 맞게 추가/제거                    │
│  - 예: "프로젝트 관리 위주면 status에 'backlog' 추가 추천"     │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Step 4: 태그 규칙 설정                                      │
│  - max_tags, lowercase, hierarchical 설정                   │
│  - 기존 태그 분석 후 규칙 제안                                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Step 5: Footer Marker 및 임베딩                             │
│  - Footer marker 개념 설명                                   │
│  - 기존 노트에 마커 추가 여부 확인                            │
│  - 임베딩 인덱스 빌드 실행                                    │
└─────────────────────────────────────────────────────────────┘
```

**대화 예시**:

```
AI: 볼트를 분석해봤어요. 현재 상태:
    - 노트 42개 (Notes/ 35개, Projects/ 7개)
    - Frontmatter 있는 노트: 38개 (90%)
    - 기존 type 값: note, project, reference

    기본 스키마를 제안드릴게요. 수정하고 싶은 부분 있으면 말씀해주세요.

User: reference 대신 term이라는 타입을 쓰고 싶어. 그리고 area에 'health' 추가해줘.

AI: 알겠어요! 스키마를 이렇게 수정할게요:
    - types: ["note", "term", "project", "log"]
    - areas: ["work", "tech", "life", "career", "learning", "reference", "health"]

    다음으로 태그 규칙을 설정할게요...
```

### 3. MCP Tool: `vault_setup`

새로운 MCP 도구 추가:

```json
{
  "name": "vault_setup",
  "description": "Interactive vault setup wizard. Use when user asks for '초기 설정', 'setup', 'onboarding'. Returns current step and prompts for user input.",
  "parameters": {
    "action": {
      "type": "string",
      "enum": ["check", "analyze", "step"],
      "description": "check: readiness status, analyze: deep analysis for wizard, step: execute specific step"
    },
    "step": {
      "type": "string",
      "enum": ["folders", "schema", "tags", "footer", "index"],
      "description": "Which setup step to execute (required when action=step)"
    },
    "config": {
      "type": "object",
      "description": "Configuration to apply for the step (user customizations)"
    }
  }
}
```

**Response 예시 (check):**
```json
{
  "status": "needs_onboarding",
  "readiness": {
    "has_config": false,
    "has_embeddings": false,
    "has_folder_structure": true,
    "footer_coverage": 0.23,
    "schema_compliance": 0.85
  },
  "recommendations": [
    "Generate .elysium.json config file",
    "Build embeddings index (42 notes)",
    "Add footer markers to 32 notes"
  ],
  "next_action": "Run vault_setup with action='full' to complete setup"
}
```

**Response 예시 (full, dry_run=false):**
```json
{
  "status": "completed",
  "actions_taken": [
    "Created .elysium.json with default config",
    "Built embeddings index for 42 notes",
    "Added footer markers to 32 notes",
    "Fixed 3 schema violations"
  ],
  "readiness": {
    "has_config": true,
    "has_embeddings": true,
    "has_folder_structure": true,
    "footer_coverage": 1.0,
    "schema_compliance": 0.95
  }
}
```

### 3. Trigger Word Detection

MCP 서버의 instructions에 트리거 워드 힌트 추가:

```rust
fn get_info(&self) -> ServerInfo {
    ServerInfo {
        instructions: Some(
            r#"Second Brain Vault MCP Server with semantic search.

IMPORTANT: When user mentions any of these phrases, use vault_setup tool:
- "초기 설정", "설정해줘", "셋업", "온보딩"
- "setup", "initialize", "onboard", "configure elysium"
- "처음 사용", "시작하기", "getting started"

For existing vaults, vault_setup check will report current status.
For new vaults, recommend vault_setup full to complete initialization."#.to_string()
        ),
        ..Default::default()
    }
}
```

### 4. CLI Command: `elysium setup`

새로운 CLI 명령어:

```bash
# Check setup status
elysium setup

# Run full setup (interactive)
elysium setup --full

# Non-interactive full setup
elysium setup --full --yes

# Dry run
elysium setup --full --dry-run
```

**출력 예시:**
```
Elysium Setup Wizard
==================================================

Checking vault readiness...

  Config (.elysium.json):     ✗ Missing
  Folder Structure:           ✓ Complete
  Embeddings Index:           ✗ Not built
  Footer Markers:             23% (32/42 notes missing)
  Schema Compliance:          85%

Recommended Actions:
  1. Generate .elysium.json config file
  2. Build embeddings index
  3. Add footer markers to notes

Run 'elysium setup --full' to complete all setup tasks.
```

### 5. 자동 온보딩 플로우

```
┌─────────────────────────────────────────────────────────────┐
│  User connects MCP / runs vault_status                       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Check VaultReadiness                                        │
│  - has_config?                                               │
│  - has_embeddings?                                           │
│  - footer_coverage?                                          │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              │                               │
              ▼                               ▼
┌─────────────────────────┐     ┌─────────────────────────────┐
│  needs_onboarding()     │     │  is_fully_ready()           │
│  = true                 │     │  = true                     │
└─────────────────────────┘     └─────────────────────────────┘
              │                               │
              ▼                               ▼
┌─────────────────────────┐     ┌─────────────────────────────┐
│  Return setup hint in   │     │  Normal operation           │
│  response:              │     │                             │
│  "Setup incomplete.     │     │                             │
│  Use vault_setup tool"  │     │                             │
└─────────────────────────┘     └─────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────┐
│  User/AI runs vault_setup full                               │
└─────────────────────────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────┐
│  1. Generate .elysium.json (if missing)                      │
│  2. Create folder structure (if missing)                     │
│  3. Add footer markers to all notes                          │
│  4. Build embeddings index                                   │
│  5. Run validation & report                                  │
└─────────────────────────────────────────────────────────────┘
```

### 6. Footer Marker 자동 추가

`elysium fix --footer` 확장:

```rust
/// Footer marker format (v2)
const FOOTER_START: &str = "<!-- elysium:footer_start -->";
const FOOTER_END: &str = "<!-- elysium:footer_end -->";

/// Add footer markers to note if missing
fn add_footer_markers(content: &str) -> String {
    if content.contains(FOOTER_START) {
        return content.to_string(); // Already has markers
    }

    // Find natural footer section (links, references, etc.)
    // Or add at the end
    format!("{}\n\n{}\n{}\n",
        content.trim_end(),
        FOOTER_START,
        FOOTER_END
    )
}
```

### 7. 스키마 자동 보정

온보딩 시 스키마 위반 자동 수정 옵션:

```rust
pub struct SchemaFixer {
    config: SchemaConfig,
}

impl SchemaFixer {
    /// Auto-fix common schema issues
    pub fn fix_frontmatter(&self, fm: &mut Frontmatter) -> Vec<String> {
        let mut fixes = Vec::new();

        // Fix missing type (default to "note")
        if fm.note_type.is_none() {
            fm.note_type = Some("note".to_string());
            fixes.push("Added default type: note".to_string());
        }

        // Fix missing status (default to "active")
        if fm.status.is_none() {
            fm.status = Some("active".to_string());
            fixes.push("Added default status: active".to_string());
        }

        // Fix non-lowercase tags
        let fixed_tags: Vec<String> = fm.tags
            .iter()
            .map(|t| t.to_lowercase())
            .collect();
        if fixed_tags != fm.tags {
            fm.tags = fixed_tags;
            fixes.push("Converted tags to lowercase".to_string());
        }

        fixes
    }
}
```

## Schema Reference Documentation

AI가 온보딩 시 참조할 스키마 문서. 각 필드의 **목적, 사용법, 커스텀 가이드** 포함.

### schema-reference.json

MCP 서버가 로드하여 AI에게 제공하는 스키마 레퍼런스:

```json
{
  "version": 1,
  "fields": {
    "type": {
      "purpose": "노트의 성격과 용도를 분류",
      "description": "노트가 어떤 종류의 정보를 담고 있는지 나타냅니다. 검색 필터링과 대시보드 구성에 사용됩니다.",
      "defaults": {
        "note": {
          "description": "일반적인 지식 노트. 특정 주제에 대한 정보, 인사이트, 요약 등",
          "examples": ["GPU 아키텍처 정리", "회의 내용 요약", "독서 노트"],
          "folder": "Notes/"
        },
        "term": {
          "description": "용어/개념 정의. 사전처럼 특정 개념을 명확하게 정의",
          "examples": ["Transformer", "RAG", "Vector Database"],
          "folder": "Notes/"
        },
        "project": {
          "description": "프로젝트 단위의 작업. 목표, 진행상황, 결과물을 추적",
          "examples": ["웹사이트 리뉴얼", "논문 작성", "사이드 프로젝트"],
          "folder": "Projects/ (active) or Archive/ (done)"
        },
        "log": {
          "description": "시간순 기록. 일지, 회고, 변경 이력 등",
          "examples": ["2024-01 회고", "프로젝트 진행 로그", "학습 일지"],
          "folder": "Notes/"
        }
      },
      "customization_guide": "자신의 노트 스타일에 맞게 추가 가능. 예: 'recipe'(요리법), 'review'(리뷰), 'quote'(인용)"
    },
    "status": {
      "purpose": "노트/프로젝트의 현재 상태 추적",
      "description": "작업 흐름에서 현재 위치를 나타냅니다. 특히 프로젝트 관리에 유용합니다.",
      "defaults": {
        "active": {
          "description": "현재 진행 중이거나 자주 참조하는 상태",
          "use_when": "작업 중인 프로젝트, 계속 업데이트되는 노트"
        },
        "done": {
          "description": "완료된 상태. 더 이상 수정이 필요 없음",
          "use_when": "프로젝트 완료, 최종 버전 노트"
        },
        "archived": {
          "description": "보관 상태. 참조용으로 유지하지만 활성 작업 아님",
          "use_when": "오래된 프로젝트, 역사적 기록"
        }
      },
      "customization_guide": "워크플로우에 맞게 추가 가능. 예: 'backlog'(대기), 'review'(검토중), 'paused'(일시중단)"
    },
    "area": {
      "purpose": "생활/관심 영역별 분류",
      "description": "노트가 속하는 삶의 영역. 관심사별 필터링과 균형 잡힌 지식 관리에 유용합니다.",
      "defaults": {
        "work": {
          "description": "직장/업무 관련",
          "examples": ["업무 프로세스", "동료 피드백", "회사 정책"]
        },
        "tech": {
          "description": "기술/개발 관련",
          "examples": ["프로그래밍", "시스템 설계", "도구 사용법"]
        },
        "life": {
          "description": "일상/개인 생활",
          "examples": ["취미", "여행", "인간관계"]
        },
        "career": {
          "description": "커리어/성장 관련",
          "examples": ["이직 준비", "스킬 개발", "네트워킹"]
        },
        "learning": {
          "description": "학습/교육 관련",
          "examples": ["온라인 강의", "책 정리", "튜토리얼"]
        },
        "reference": {
          "description": "참조 자료",
          "examples": ["치트시트", "자주 쓰는 명령어", "템플릿"]
        }
      },
      "customization_guide": "개인 관심사에 맞게 추가. 예: 'health'(건강), 'finance'(재정), 'creative'(창작)"
    },
    "gist": {
      "purpose": "노트의 핵심 요약 (시맨틱 검색용)",
      "description": "2-3문장으로 노트의 핵심 내용을 요약. AI 시맨틱 검색의 주요 입력값으로, 검색 품질에 직접 영향을 미칩니다.",
      "guidelines": {
        "length": "50-100 단어 권장",
        "content": "노트의 핵심 주장, 결론, 또는 주요 정보 포함",
        "style": "명확하고 구체적으로. 검색될 때 이 내용으로 매칭됨",
        "avoid": "너무 일반적인 설명, 메타 정보('이 노트는...')"
      },
      "examples": {
        "good": "GPU의 Unified Memory 아키텍처는 CPU-GPU 간 데이터 복사 오버헤드를 제거하여 메모리 대역폭 효율을 40% 향상시킨다. Apple Silicon과 최신 NVIDIA GPU에서 지원.",
        "bad": "GPU 메모리에 대한 노트입니다."
      }
    },
    "tags": {
      "purpose": "세부 주제 태깅 (교차 분류)",
      "description": "area와 type으로 분류되지 않는 세부 주제나 키워드. 관련 노트 연결에 사용됩니다.",
      "rules": {
        "max_tags": {
          "default": 5,
          "reason": "태그가 너무 많으면 의미가 희석됨"
        },
        "lowercase_tags": {
          "default": true,
          "reason": "일관성 유지, 중복 방지"
        },
        "allow_hierarchical_tags": {
          "default": false,
          "reason": "플랫 구조가 검색과 연결에 더 효과적",
          "alternative": "계층이 필요하면 area를 활용"
        }
      },
      "guidelines": {
        "do": ["구체적인 키워드 사용", "재사용 가능한 태그 선호", "영어 또는 한글 일관되게"],
        "dont": ["문장형 태그", "일회성 태그", "너무 일반적인 태그 (예: 'important')"]
      }
    }
  },
  "footer_markers": {
    "purpose": "노트 본문과 메타데이터 영역 구분",
    "description": "Footer marker는 노트 하단의 참조 링크, 관련 노트 목록 등을 본문과 구분합니다. 시맨틱 검색 시 footer 영역은 제외되어 검색 품질이 향상됩니다.",
    "format": {
      "start": "<!-- elysium:footer_start -->",
      "end": "<!-- elysium:footer_end -->"
    },
    "example": "```markdown\n본문 내용...\n\n<!-- elysium:footer_start -->\n## Related Notes\n- [[관련 노트 1]]\n- [[관련 노트 2]]\n<!-- elysium:footer_end -->\n```"
  }
}
```

### AI Instructions for Onboarding

MCP 서버 instructions에 포함될 가이드:

```
When helping users set up their vault, reference the schema documentation to:

1. EXPLAIN each field's purpose before asking for customization
2. SUGGEST defaults based on their use case:
   - "프로젝트 관리 위주" → status에 'backlog', 'review' 추가 제안
   - "학습 노트 위주" → type에 'summary', 'question' 추가 제안
   - "일기/저널링" → type에 'journal', status에 'draft' 추가 제안

3. VALIDATE user customizations:
   - Values should be lowercase, single words
   - Avoid duplicates across fields (e.g., 'learning' in both type and area)
   - Warn if too many values (>10 per field reduces usefulness)

4. GUIDE gist writing:
   - Show good/bad examples
   - Offer to help write gists for existing notes

5. EXPLAIN footer markers:
   - Why they matter for search quality
   - Offer to add them to existing notes
```

## Implementation Plan

### Phase 1: Schema Documentation
- [ ] `schema-reference.json` 파일 생성 (볼트 내 `.elysium/` 또는 MCP 내장)
- [ ] 각 필드별 purpose, defaults, customization_guide 작성
- [ ] MCP 서버가 schema reference 로드하도록 구현
- [ ] `vault_schema_help` MCP 도구 추가 (필드별 설명 조회)

### Phase 2: Vault Analysis
- [ ] `VaultReadiness` struct 구현
- [ ] 기존 frontmatter 패턴 분석 기능
- [ ] 기존 폴더 구조 감지
- [ ] 사용 중인 type/status/area 값 수집
- [ ] `vault_setup analyze` 액션 구현

### Phase 3: Interactive Wizard
- [ ] `vault_setup` MCP 도구 구현
- [ ] step별 실행: folders → schema → tags → footer → index
- [ ] 각 step에서 기본값 제안 + 유저 커스텀 수용
- [ ] 유효성 검증 (lowercase, 중복 체크 등)
- [ ] 최종 `.elysium.json` 생성

### Phase 4: CLI Wizard
- [ ] `elysium setup` 명령어 추가
- [ ] Interactive 모드 (터미널에서 단계별 질문)
- [ ] `--yes` 플래그로 기본값 자동 적용
- [ ] Progress reporting

### Phase 5: Auto-fix Features (유저 확인 후 실행)
- [ ] Footer marker 추가 (dry-run 먼저, 확인 후 적용)
- [ ] Gist 자동 생성 제안 (빈 gist 노트에 대해)
- [ ] 임베딩 인덱스 빌드 (with progress)

### Phase 6: Polish
- [ ] MCP instructions에 트리거 워드 가이드 추가
- [ ] 온보딩 완료 후 "다음 단계" 가이드
- [ ] README 업데이트
- [ ] `/vault/setup` 슬래시 커맨드 추가

## API Changes

### New MCP Tools

```typescript
// 1. Interactive Setup Wizard
vault_setup(
  action: "check" | "analyze" | "step",
  step?: "folders" | "schema" | "tags" | "footer" | "index",
  config?: object  // user customizations
)

// 2. Schema Help (AI가 설명할 때 참조)
vault_schema_help(
  field?: "type" | "status" | "area" | "gist" | "tags" | "footer"
)
```

### New CLI Commands
```bash
elysium setup              # Interactive wizard
elysium setup --yes        # Use defaults, no prompts
elysium setup --check      # Status only
```

### New Slash Command
```
/vault/setup    # Trigger interactive onboarding wizard
```

### Modified Tools
- `vault_status`: readiness 정보 포함 + onboarding 필요 시 힌트
- `vault_health`: onboarding 상태 표시

### New Files
- `.elysium/schema-reference.json` - 스키마 레퍼런스 (MCP 서버 내장 또는 볼트 내 생성)

## Backward Compatibility

- 기존 볼트에서 아무 변경 없이 동작
- 새 도구/명령어 추가만 있음
- Breaking change 없음
- schema-reference.json 없어도 기본값으로 동작

## Success Metrics

1. **온보딩 완료율**: 첫 사용자가 10분 내에 fully_ready 상태 도달
2. **커스터마이징**: 50% 이상의 사용자가 기본값에서 1개 이상 수정
3. **이해도**: 온보딩 후 사용자가 gist 필드의 목적을 이해
4. **검색 품질**: 온보딩 완료 후 semantic search 즉시 사용 가능

## Design Decisions

### 1. 가이드 우선, 자동화 보조
- 모든 설정을 설명하고 유저 확인 후 적용
- AI가 스키마 레퍼런스를 참조하여 맥락있는 설명 제공
- "왜 이렇게 하는지" 이해하면 이후 유지보수가 쉬움

### 2. 점진적 적용
- 한꺼번에 모든 걸 바꾸지 않음
- 폴더 → 스키마 → 태그 → footer → 임베딩 순서
- 각 단계에서 중단 가능

### 3. 기존 패턴 존중
- 유저가 이미 사용 중인 type/status/area 값 감지
- 기존 값을 기본 스키마에 병합 제안
- "이미 'reference' 타입을 쓰고 계시네요, 기본 스키마에 추가할까요?"

### 4. Footer Marker 설명 필수
- 검색 품질에 직접 영향
- 개념 이해 없이 자동 추가하면 나중에 혼란
- dry-run으로 미리보기 후 적용

---

**Target Version**: v0.3.0
**Estimated Effort**: 5-6 days
**Priority**: High (FTUE impact)
